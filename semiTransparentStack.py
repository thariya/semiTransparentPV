##Use this file to generate Reflectance and Transmittance Spectra for any stack of textured solar cell with some areas just being glass, and others being a full solar cell stack
##It runs 2 simulations. First an empty background simulation to determine the background fluxes when no object is present. Then the full simulation is run and the fluxes from the background are
##subtracted to evaluate the fluxes generated by the structure itself. The reflectance and transmittance values are output at the end, along with the frequencies. The glass is in the full width of the
##periodic cell and the rest of the stack is half the width.
# Length units are in um and frequency is in inverse um.

import math
import cmath
import numpy as np
import argparse
import sys
import meep as mp
from meep.materials import Au, ITO
import csv
import matplotlib.pyplot as plt

nfreq=500  #Number of frequency points

def main(args):
  #The width of each unit cell in um units. A unit cell consists of a portion with pure glass and another with a semi-transparent solar cell stack
  widths=[0.01,0.02,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0, 90.0, 100.0]
  numwidths=len(widths)
   
  refs=np.zeros(shape=(numwidths,nfreq))
  trans=np.zeros(shape=(numwidths,nfreq))
  absorp=np.zeros(shape=(numwidths,nfreq))
  freqs=[]

  
  for i in range(numwidths):
    width=widths[i]
    print("################## ",width," microns #################")
    print("##############################################")
    wavelengths, reflectance, transmittance, absorptance= get_optics(args,width)
    refs[i,:]=reflectance
    trans[i,:]=transmittance
    absorp[i,:]=absorptance
    freqs=wavelengths
  freqs=np.array(freqs)
  widths = np.array(widths)

  #Save the calculated values
  np.savetxt("ref.csv",refs,delimiter=",")
  np.savetxt("trans.csv",trans,delimiter=",")
  np.savetxt("abs.csv",absorp,delimiter=",")
  np.savetxt("freqs.csv",freqs,delimiter=",")
  np.savetxt("widths.csv", widths, delimiter=",")

 
def get_optics(args, width):

  ##Setup frequency values in units of inverse wavelength(Here, wavelengths are measured in microns)
  fmax=1/0.35
  fmin=1/0.85
  fcen=(fmax+fmin)/2.0  # Center frequency
  df = fmax-fmin         # frequency width

  ##Setup the materials in the Lorentz-Drude model susceptibilites. The susceptibilites can be determined from a different script that is available. It simply involves a fitting of experimental refractive indices
  FAPbI3_susc = [ mp.LorentzianSusceptibility(frequency=2.67424, gamma=7.14323, sigma=2.88499),
                mp.LorentzianSusceptibility(frequency=1.95198, gamma=3.44101, sigma=0.76677) ]

  FAPbI3 = mp.Medium(epsilon=2.08658, E_susceptibilities=FAPbI3_susc)   

  Spiro_susc = [mp.LorentzianSusceptibility(frequency=2.53, gamma=4.976, sigma=105)]

  Spiro = mp.Medium(epsilon=2.55, E_susceptibilities=Spiro_susc) 

  angle=args.src_angle
  
  resolution = args.res  # pixels/um

  dito = 0.15             # ITO thickness
  dsno2 = 0.03             # SnO2 thicknees
  dabs = 0.2             # absorber thickness
  dspiro = 0.15            # Spiro thickness
  dau = 0.02            # Au thickness


  dpml = 1.0             # PML length
  dair = 2.0             # Air padding length between PML and grating
  dsub = 2.0             # glass substrate thickness
  d = width            # Unit Cell period
  
  n = args.nn            # Acpect ratio

  ##Total x length of the periodic cell
  sx = dpml+dair+dau+dspiro+dabs+dsno2+dito+dsub+dpml
  ## total y length of periodic cell
  sy = d
  
  ##Total cell size as a 3D vector
  cell_size = mp.Vector3(sx,sy,0)
  ##Define PML layers
  pml_layers = [mp.Absorber(thickness=dpml,direction=mp.X)]

  ng = 1.525             # glass substrate refractive index
  nsource=ng   ##Source refractive index(glass in this specific case)
  glass = mp.Medium(index=ng)

  ## Setup the polarization of the incident beam
  if args.src_pol == 1:
    src_cmpt = mp.Ez
    eig_parity = mp.ODD_Z
  elif args.src_pol == 2:
    src_cmpt = mp.Hz
    eig_parity = mp.EVEN_Z
  else:
    sys.exit("error: src_pol={} is invalid".format(args.src_pol))

  # rotation angle of incident planewave source; CCW about Z axis, 0 degrees along +X axis
  theta_src = math.radians(angle)
  
  # k (in source medium) with correct length normalised based upon frequency (plane of incidence: XY)
  if theta_src == 0:
    k=(mp.Vector3(0,0,0))
  else:
    k=(mp.Vector3(math.cos(theta_src)),math.sin(theta_src),0).scale(fcen)
    
  def pw_amp(k,x0):
    def _pw_amp(x):
      return cmath.exp(1j*2*math.pi*k.dot(x+x0))
    return _pw_amp

  src_pt = mp.Vector3(-0.5*sx+dpml+0.2*dsub,0,0)  ##The center point of the incident beam source
  refl_pt = mp.Vector3(-0.5*sx+dpml,0,0)  ##The center point of the reflectance monitor
  tran_pt = mp.Vector3(0.5*sx-dpml,0,0)  ##The center point of the transmittance monitor
  bot_pt = mp.Vector3(-0.5*sx+dpml+dsub+dito+dsno2,0,0)  ##The center point of the bottom perovskite monitor
  top_pt = mp.Vector3(-0.5*sx+dpml+dsub+dito+dsno2+dabs,0,0)  ##The center point of the top perovskite monitor
  left_pt = mp.Vector3(-0.5*sx+dpml+dsub+dito+dsno2+dabs/2.0,-sy/(n*2.0),0)  ##The center point of the top perovskite monitor
  right_pt = mp.Vector3(-0.5*sx+dpml+dsub+dito+dsno2+dabs/2.0,sy/(2*n),0)  ##The center point of the top perovskite monitor
  
  ##Declare sources as a list. Here we define a Gaussian pulse of required center frequency and frequency width to be able to simulate the total frequency range in one go
  sources = [ mp.Source(mp.GaussianSource(fcen, fwidth=df,is_integrated=True), component=src_cmpt, center=src_pt, size=mp.Vector3(0, sy, 0)) ]


  ##Declare the bare minimum background geometry. This is setup to be declared as the background of the simulation. We run this simulation and subract the values from the full simulation reflectance spectrum later
  geometry = [mp.Block(material=glass, size=mp.Vector3(mp.inf,mp.inf,mp.inf), center=mp.Vector3(0,0,0))]
  #geometry=[]

  ##Setup background simulation with paramters we defined earlier
  sim = mp.Simulation(resolution=resolution,
                          cell_size=cell_size,
                          boundary_layers=pml_layers,
                          k_point=k,  
                          dimensions=2,      
                          sources=sources,
                          geometry=geometry)
  ##Add reflectance monitor at given center point and of specified size
  refl_flux = sim.add_flux(fcen, df, nfreq, mp.FluxRegion(center=refl_pt, size=mp.Vector3(0,sy,0)))

  ##Setup the transmittance monitor
  tran_flux = sim.add_flux(fcen, df, nfreq, mp.FluxRegion(center=tran_pt, size=mp.Vector3(0,sy,0)))
  
  ##Run background simulation
  sim.run(until_after_sources=mp.stop_when_fields_decayed(50, src_cmpt, mp.Vector3(0.5*sx-dpml-0.5*dair,0,0), 1e-8))
  sim.save_flux('refl', refl_flux)

  ##Save the background fluxes
  input_flux_ref = mp.get_fluxes(refl_flux)
  input_flux_tran = mp.get_fluxes(tran_flux)
  
  sim.display_fluxes(refl_flux,tran_flux)

  ############################################
  ####Reset simulation to run actual setup####
  ############################################
  
  sim.reset_meep()

  ##Setup geometry using blocks. The center of each block and material needs to be mentioned. Each subsequent block overrides the previous block and material if they overlap
  geometry = [mp.Block(material=glass, size=mp.Vector3(dpml+dsub,mp.inf,mp.inf), center=mp.Vector3(-0.5*sx+0.5*(dpml+dsub),0,0)),
                    mp.Block(material=Spiro, size=mp.Vector3(dito,sy/n,mp.inf), center=mp.Vector3(-0.5*sx+dpml+dsub+0.5*dito,0,0)),
                    mp.Block(material=Spiro, size=mp.Vector3(dsno2,sy/n,mp.inf), center=mp.Vector3(-0.5*sx+dpml+dsub+dito+0.5*dsno2,0,0)),
                    mp.Block(material=FAPbI3, size=mp.Vector3(dabs,sy/n,mp.inf), center=mp.Vector3(-0.5*sx+dpml+dsub+dito+dsno2+0.5*dabs,0,0)),
                    mp.Block(material=Spiro, size=mp.Vector3(dspiro,sy/n,mp.inf), center=mp.Vector3(-0.5*sx+dpml+dsub+dito+dsno2+dabs+0.5*dspiro,0,0)),
                    mp.Block(material=Spiro, size=mp.Vector3(dau,sy/n,mp.inf), center=mp.Vector3(-0.5*sx+dpml+dsub+dito+dsno2+dabs+dspiro+0.5*(dau),0,0))]
  #geometry = [mp.Block(material=glass, size=mp.Vector3(dpml+dsub,mp.inf,mp.inf), center=mp.Vector3(-0.5*sx+0.5*(dpml+dsub),0,0))]
  ##Setup simulation with the earlier setup parameters
  sim = mp.Simulation(resolution=resolution,
                          cell_size=cell_size,
                          boundary_layers=pml_layers,
                          k_point=k,
                          dimensions=2, 
                          sources=sources,
                          geometry=geometry)
						  
  ##Set up the dft field object to monitor local fields within the absorber layers
  dft_fields = sim.add_dft_fields([mp.Dz,mp.Ez],
                                fcen,df,nfreq,
                                center=mp.Vector3(-0.5*sx+dpml+dsub+dito+dsno2+0.5*dabs,0,0),
                                size=mp.Vector3(dabs,sy/n,mp.inf),
                                yee_grid=True)
                          
                          
  ##Setup Reflectance monitor and subtract the background flux from the calculated new flux
  refl_flux = sim.add_flux(fcen, df, nfreq, mp.FluxRegion(center=refl_pt, size=mp.Vector3(0,sy,0)))
  sim.load_minus_flux('refl', refl_flux)
      
  ##Setup the transmittance monitor
  tran_flux = sim.add_flux(fcen, df, nfreq, mp.FluxRegion(center=tran_pt, size=mp.Vector3(0,sy,0)))

  ##Setup the four absoprtance monitors
  bot_flux = sim.add_flux(fcen, df, nfreq, mp.FluxRegion(center=bot_pt, size=mp.Vector3(0,sy/n,0)))
  top_flux = sim.add_flux(fcen, df, nfreq, mp.FluxRegion(center=top_pt, size=mp.Vector3(0,sy/n,0)))
  left_flux = sim.add_flux(fcen, df, nfreq, mp.FluxRegion(center=left_pt, size=mp.Vector3(dabs,0,0)))
  right_flux = sim.add_flux(fcen, df, nfreq, mp.FluxRegion(center=right_pt, size=mp.Vector3(dabs,0,0)))

  ##Run the full simulation
  #sim.run(mp.at_beginning(mp.output_epsilon),mp.to_appended("ez", mp.at_every(0.6, mp.output_efield_z)), until_after_sources=mp.stop_when_fields_decayed(50, src_cmpt, mp.Vector3(0.5*sx-dpml-0.5*dair,0,0), 1e-3))
  sim.run(until_after_sources=mp.stop_when_fields_decayed(50, src_cmpt, mp.Vector3(0.5*sx-dpml-0.5*dair,0,0), 1e-8))

  ##Calculate the inverse frequency(wavelengths)
  frs=np.array(mp.get_flux_freqs(refl_flux))
  frs=1/frs

  #Calculate the transmittance and reflectance through the monitors we set up earlier
  r_flux = -np.array(mp.get_fluxes(refl_flux))/np.array(input_flux_tran)
  t_flux = np.array(mp.get_fluxes(tran_flux))/np.array(input_flux_tran)
  top_flux = np.array(mp.get_fluxes(top_flux))/np.array(input_flux_tran)
  bot_flux = np.array(mp.get_fluxes(bot_flux))/np.array(input_flux_tran)
  ll_flux = np.array(mp.get_fluxes(left_flux))/np.array(input_flux_tran)
  rr_flux = np.array(mp.get_fluxes(right_flux))/np.array(input_flux_tran)
  a_flux= bot_flux-top_flux+ll_flux-rr_flux
  
  sim.display_fluxes(refl_flux,tran_flux)
  
  return frs, r_flux, t_flux, a_flux
  
    
if __name__ == '__main__':
  parser = argparse.ArgumentParser()
  parser.add_argument('-res', type=int, default=100, help='resolution (default: 100 pixels/um)')
  parser.add_argument('-src_pol', type=int, default=1, help='source polarization (1: Ez, 2: Hz, default: Ez)')
  parser.add_argument('-src_angle', type=float, default=0, help='source angle (default: 0 degrees)')
  parser.add_argument('-dd', type=float, default=0.6, help='grating periodicity (default: 0.6 um)')
  parser.add_argument('-nn', type=float, default=2.0, help='aspect ratio of total unit cell length to solar cell stack length (default: 2)')
  args = parser.parse_args()
  main(args)
